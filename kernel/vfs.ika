#if !VFS
#define VFS

#include "malloc.ika"
#include "string.ika"

struct SuperBlock;
struct INode;
struct File;

const SB_RDONLY = 1 << 0;

const SEEK_SET = 0;
const SEEK_CUR = 1;
const SEEK_END = 2;

const S_IFMT = 0xF000;
const S_IFSOCK = 0xC000;
const S_IFLNK = 0xA000;
const S_IFREG = 0x8000;
const S_IFBLK = 0x6000;
const S_IFDIR = 0x4000;
const S_IFCHR = 0x2000;
const S_IFIFO = 0x1000;

const S_ISUID = 0x0800;
const S_ISGID = 0x0400;
const S_ISVTX = 0x0200;

const S_IRUSR = 0x0100;
const S_IWUSR = 0x0080;
const S_IXUSR = 0x0040;
const S_IRGRP = 0x0020;
const S_IWGRP = 0x0010;
const S_IXGRP = 0x0008;
const S_IROTH = 0x0004;
const S_IWOTH = 0x0002;
const S_IXOTH = 0x0001;

const O_RDONLY    = 0x0000;
const O_WRONLY    = 0x0001;
const O_RDWR      = 0x0002;
const O_APPEND    = 0x0008;
const O_CREAT     = 0x0200;
const O_TRUNC     = 0x0400;
const O_EXCL      = 0x0800;
const O_NOFOLLOW  = 0x1000;
const O_PATH      = 0x2000;
const O_NONBLOCK  = 0x4000;
const O_DIRECTORY = 0x8000;

struct BlockDevice {
    read: fn(
        ctx: *void,
        lba: u32,
        cnt: u32,
        buf: *void
    ) i32,
    ctx: *void,
    sector_size: u32,
};

// helper
fn bd_blk_to_lba(block: u32, block_size: u32, sector_size: u32) u32 {
    return (block * block_size) / sector_size;
}

struct SuperOps {
    read_inode: fn(ino: *INode) i32,
    put_inode: fn(ino: *INode) void,
    put_super: fn(sb: *SuperBlock) void,
};

struct SuperBlock {
    magic: u32,
    block_size: u32,
    flags: u32,
    ops: *SuperOps,
    bd: *BlockDevice,
    private: *void,
    root_inode: *INode,
    reference_count: u32,
};

struct INodeOps {
    lookup: fn(
        dir: *INode,
        name: []u8,
        out: **INode
    ) i32,
};

struct FileOps;

struct INode {
    ino_no: u32,
    mode: u16, // S_IFDIR, S_IFREG, etc
    size: u32,
    blocks: u32,
    sb: *SuperBlock,
    ops: *INodeOps,
    f_ops: *FileOps,
    private: *void,
    reference_count: u32,
};

struct FileOps {
    read: fn(f: *File, buf: *void, len: u32) i32,
    lseek: fn(f: *File, off: u32, whence: u32) i32,
    close: fn(f: *File) i32,
};

struct File {
    inode: *INode,
    pos: u32,
    ops: *FileOps,
    flags: u32, // O_RDONLY, O_WDONLY, etc.
};

struct FileSystemType {
    name: []u8,
    mount: fn(
        bd: *BlockDevice,
        out_sb: **SuperBlock
    ) i32,
    next: *FileSystemType,
};

struct Mount {
    mountpoint: *INode,
    child_sb: *SuperBlock,
    next: *Mount,
};

var fs_drivers: *FileSystemType = null;
var fs_mount_list: *Mount = null;

fn vfs_register(fst: *FileSystemType) i32 {
    var p: *FileSystemType = fs_drivers;
    while (p != null) : (p = p.next) {
        if (strcmp(p.name, fst.name) == 0) {
            return -1;
        }
    }

    fst.next = fs_drivers;
    fs_drivers = fst;
    return 0;
}

var vfs_root_sb: *SuperBlock = null;

fn _vfs_try_mount(
    fst: *FileSystemType,
    bd: *BlockDevice,
    out: **SuperBlock
) i32 {
    var sb: *SuperBlock;
    var status: i32 = fst.mount(bd, &sb);
    if (status != 0) {
        return status;
    }

    *out = sb;
    return 0;
}

fn path_resolve(path: []u8, out: **INode) i32;

fn vfs_mount(
    bd: *BlockDevice,
    fs_name: []u8,
    mount_path: []u8,
    out_sb: **SuperBlock
) i32 {
    var status: i32 = 0;

    var mp: *INode;
    if (vfs_root_sb == null) {
        if (mount_path[0] != '/' || mount_path[1] != 0) {
            return -1;
        }
        mp = null;
    } else {
        status = path_resolve(mount_path, &mp);
        if (status != 0) {
            return status;
        }

        if ((mp.mode & S_IFMT) != S_IFDIR) {
            return -1;
        }
    }

    var m: *Mount = fs_mount_list;
    while (m != null) : (m = m.next) {
        if (m.mountpoint == mp) {
            return -1;
        }
    }

    var fst: *FileSystemType;
    var new_sb: *SuperBlock;
    if (fs_name != null) {
        fst = fs_drivers;
        while (fst != null) : (fst = fst.next) {
            if (strcmp(fst.name, fs_name) == 0) {
                break;
            }
        }

        if (fst == null) {
            return -1;
        }

        status = _vfs_try_mount(fst, bd, &new_sb);
        if (status != 0) {
            return status;
        }
    } else {
        // No name, try each driver
        fst = fs_drivers;
        while (fst != null) : (fst = fst.next) {
            if (_vfs_try_mount(fst, bd, &new_sb) == 0) {
                break;
            }
        }

        if (fst == null) {
            return -1;
        }
    }

    var link: *Mount = malloc(sizeof(Mount));
    link.mountpoint = mp;
    link.child_sb = new_sb;
    link.next = fs_mount_list;
    fs_mount_list = link;

    if (vfs_root_sb == null) {
        vfs_root_sb = new_sb;
    }

    if (out_sb != null) {
        *out_sb = new_sb;
    }
    return 0;
}

fn _path_split_first(path:* []u8, out: []u8, cap: u32) i32 {
    while ((*path)[0] == '/') {
        (*path) += 1;
    }

    if ((*path)[0] == 0) {
        return 0;
    }

    var i: u32 = 0;
    while ((*path)[0] != 0 && (*path)[0] != '/') : ((*path) += 1) {
        if (i < cap - 1) {
            out[i] = (*path)[0];
            i += 1;
        }
    }
    out[i] = 0;
    return 1;
}

fn path_resolve(path: []u8, out: **INode) i32 {
    if (vfs_root_sb == null) {
        return -1;
    }

    var p: []u8 = path;
    var cur: *INode = vfs_root_sb.root_inode;

    const NAME_BUF_SIZE = 256;
    var name_buf: [NAME_BUF_SIZE]u8;
    while (_path_split_first(&p, &name_buf, NAME_BUF_SIZE) != 0) {
        if ((cur.mode & S_IFMT) != S_IFDIR) {
            return -1;
        }

        var m: *Mount = fs_mount_list;
        while (m != null) : (m = m.next) {
            if (m.mountpoint == cur) {
                cur = m.child_sb.root_inode;
                break;
            }
        }

        var next: *INode;
        var status: i32 = cur.ops.lookup(cur, &name_buf, &next);
        if (status != 0) {
            return status;
        }

        cur = next;
    }

    *out = cur;
    return 0;
}

fn generic_file_read(f: *File, buf: *void, len: u32) i32 {
    return 0;
}

fn generic_file_lseek(f: *File, off: u32, whence: u32) i32 {
    var pos: i32 = f.pos;
    if (whence == SEEK_SET) {
        pos = off;
    } else if (whence == SEEK_CUR) {
        pos += off;
    } else if (whence == SEEK_END) {
        pos = f.inode.size + off;
    } else {
        return -1;
    }

    if (pos < 0 || pos > f.inode.size) {
        return -1;
    }

    f.pos = pos;
    return f.pos;
};

fn generic_file_close(f: *File) i32 {
    free(f);
    return 0;
}

fn vfs_open(path: []u8, out: **File) i32 {
    var ino: *INode;
    var status: i32 = path_resolve(path, &ino);
    if (status != 0) {
        return status;
    }

    var f: *File = malloc(sizeof(File));
    if (f == null) {
        return -1;
    }

    f.inode = ino;
    f.pos = 0;
    f.ops = ino.f_ops;
    *out = f;
    return 0;
}

fn vfs_read(f: *File, buf: *void, len: u32) i32 {
    if (f.ops.read == null) {
        return -1;
    }

    var n: i32 = f.ops.read(f, buf, len);
    if (n > 0) {
        f.pos += n;
    }
    return n;
}

fn vfs_lseek(f: *File, off: i32, whence: u32) i32 {
    if (f.ops.lseek == null) {
        return -1;
    }

    return f.ops.lseek(f, off, whence);
}

fn vfs_close(f: *File) i32 {
    return f.ops.close(f);
}

fn vfs_init() void {}

#endif

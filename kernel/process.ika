#if !PROCESS
#define PROCESS

#include "deque.ika"

#include "idt.ika"

#include "syscall.ika"
#include "malloc.ika"

const KERNEL_CS = 0x08;
const KERNEL_DS = 0x10;

const KSTACK_SIZE = 16 * PAGE_SIZE;

enum {
    P_UNUSED,
    P_RUNNABLE,
    P_BLOCKED,
    P_ZOMBIE,
};

enum {
    WAIT_WAITPID,
    WAIT_SLEEP,
};

struct Process {
    prev: *Process,
    next: *Process,

    pid: i32,
    state: i32,
    cr3: u32,
    kstack_base: []u8,
    kstack_size: u32,
    esp: u32, // saved kerenl ESP

    parent: *Process,
    child_head: *Process,
    sibling_next: *Process,

    exit_status: u32,

    wait_type: i32,
    // waitpid
    wait_want_pid: i32,
    wait_regs: *regs_t,
    wait_p_status: *u32,
    // sleeping
    wakeup_tick: u32,
};

var init_proc: *Process;
var idle_proc: *Process;

var proc_current: *Process = null;
var proc_runq: Deque;
var proc_next_pid: i32 = 0;

extern fn ctx_switch(new_cr3: u32, new_esp: u32) void;

fn proc_switch_to(p: *Process) void {
    proc_current = p;
    ctx_switch(p.cr3, p.esp);
}

fn proc_schedule(r: *regs_t) void {
    if (proc_current == null) {
        panic("No current process");
    }

    // TODO: wakeup sleep processes

    var next: *Process = as(*Process, deque_pop_front(&proc_runq));
    if (next == null) {
        if (proc_current.state != P_RUNNABLE) {
            proc_switch_to(idle_proc);
        }
        return;
    }

    proc_current.esp = as(u32, r);

    if (proc_current != idle_proc && proc_current.state == P_RUNNABLE) {
        deque_push_back(&proc_runq, as(*DequeNode, proc_current));
    }

    proc_switch_to(next);
}

extern fn kthread_entry() void;

fn proc_init_frame(
    stack_top: []u8,
    entry: fn(arg: *void) u32,
    args: *void,
    cs: u16,
    ds: u16
) u32 {
    var sp: []u32 = as([]u32, stack_top);

    sp -= 1; *sp = 0x202;                   // EFLAGS
    sp -= 1; *sp = cs;                      // CS
    sp -= 1; *sp = as(u32, kthread_entry);  // EIP

    sp -= 1; *sp = 0;                       // err_code
    sp -= 1; *sp = 0;                       // int_no

    sp -= 1; *sp = as(u32, entry);          // EAX
    sp -= 1; *sp = 0;                       // ECX
    sp -= 1; *sp = 0;                       // EDX
    sp -= 1; *sp = as(u32, args);           // EBX
    sp -= 1; *sp = 0;                       // ESP (ignored)
    sp -= 1; *sp = 0;                       // EBP
    sp -= 1; *sp = 0;                       // ESI
    sp -= 1; *sp = 0;                       // EDI

    sp -= 1; *sp = ds;                      // DS
    sp -= 1; *sp = ds;                      // ES
    sp -= 1; *sp = ds;                      // FS
    sp -= 1; *sp = ds;                      // GS

    return as(u32, sp);
}

fn proc_create(
    parent: *Process,
    entry: fn(args: *void) u32,
    args: *void
) *Process {
    var p: *Process = malloc(sizeof(Process));
    memset(p, 0, sizeof(Process));
    p.pid = proc_next_pid;
    p.state = P_RUNNABLE;
    p.parent = parent;
    proc_next_pid += 1;
    p.cr3 = paging_kernel_dir_phys;

    p.kstack_base = malloc(KSTACK_SIZE);
    p.kstack_size = KSTACK_SIZE;

    p.esp = proc_init_frame(
        p.kstack_base + p.kstack_size,
        entry,
        args,
        KERNEL_CS,
        KERNEL_DS
    );

    if (parent != null) {
        p.sibling_next = parent.child_head;
        parent.child_head = p;
    }

    return p;
}

fn proc_reap(z: *Process) void {
    var pp: **Process = &z.parent.child_head;
    while (*pp != null && *pp != z) {
        pp = &(*pp).sibling_next;
    }

    if (*pp == z) {
        *pp = z.sibling_next;
    }

    free(z.kstack_base);
    free(z);
}

fn proc_wakeup(p: *Process) void {
    if (p.state != P_BLOCKED) {
        return;
    }

    p.state = P_RUNNABLE;
    deque_push_front(&proc_runq, as(*DequeNode, p));
}

fn proc_wake_waitpid_if_match(parent: *Process, child: *Process) void {
    if (parent.state != P_BLOCKED || parent.wait_type != WAIT_WAITPID) {
        return;
    }

    if (parent.wait_want_pid == -1 || parent.wait_want_pid == child.pid) {
        parent.wait_regs.eax = child.pid;
        *parent.wait_p_status = child.exit_status;
        proc_wakeup(parent);
        proc_reap(child);
    }
}

fn proc_add_child(parent: *Process, child: *Process) void {
    child.parent = parent;
    child.sibling_next = parent.child_head;
    parent.child_head = child;

    if (child.state == P_ZOMBIE) {
        proc_wake_waitpid_if_match(parent, child);
    }
}

fn proc_reparent_children(parent: *Process, adopt: *Process) void {
    var c: *Process = parent.child_head;
    while (c != null) {
        var next: *Process = c.sibling_next;
        proc_add_child(adopt, c);
        c = next;
    }

    parent.child_head = null;
}

fn idle_main(args: *void) u32 {
    while (true) {
        asm("hlt");
    }
}

fn proc_init(init: fn(args: *void) u32) void {
    deque_init(&proc_runq);

    idle_proc = proc_create(null, idle_main, null);
    init_proc = proc_create(null, init, null);

    proc_current = init_proc;
}

fn proc_start() void {
    proc_switch_to(proc_current);
}

#endif

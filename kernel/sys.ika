#if !SYS
#define SYS

#include "idt.ika"
#include "paging.ika"
#include "interrupt.ika"

#include "malloc.ika"
#include "panic.ika"
#include "process.ika"
#include "syscall.ika"

var syscall_handlers: [SYS_COUNT]fn(r: *regs_t) u32;

fn sys_exit(r: *regs_t) u32 {
    var status: u32 = r.ebx;

    var p: *Process = proc_current;
    p.exit_status = status & 0xFF;
    p.state = P_ZOMBIE;

    if (p == init_proc) {
        panic("init (PID 1) exited with status %d", p.exit_status);
    }

    proc_reparent_children(p, init_proc);

    proc_wake_waitpid_if_match(p.parent, p);

    proc_schedule(r);
    // unreachable
}

fn sys_getpid(r: *regs_t) u32 {
    return proc_current.pid;
}

fn _fork_child_frame(r: *regs_t, child_stack_top: []u8) u32 {
    var sp: []u32 = as([]u32, child_stack_top);

    if ((r.cs & 3) == 3) {
        // user-mode
        sp -= 1; *sp = r.ss;        // SS
        sp -= 1; *sp = r.useresp;   // USER ESP
    }

    sp -= 1; *sp = r.eflags;        // EFLAGS
    sp -= 1; *sp = r.cs;            // CS
    sp -= 1; *sp = r.eip;           // EIP

    sp -= 1; *sp = 0;               // err_code
    sp -= 1; *sp = 0;               // int_no 

    sp -= 1; *sp = 0;               // EAX = 0 in child
    sp -= 1; *sp = r.ecx;
    sp -= 1; *sp = r.edx;
    sp -= 1; *sp = r.ebx;
    sp -= 1; *sp = 0;               // ESP (ignored)
    sp -= 1; *sp = r.ebp;
    sp -= 1; *sp = r.esi;
    sp -= 1; *sp = r.edi;

    sp -= 1; *sp = r.ds;
    sp -= 1; *sp = r.es;
    sp -= 1; *sp = r.fs;
    sp -= 1; *sp = r.gs;

    return as(u32, sp);
}

fn sys_spawn(r: *regs_t) u32 {
    var entry: fn(args: *void) u32 = as(fn(args: *void) u32, r.ebx);
    var args: *void = as(*void, r.ecx);

    var child: *Process = proc_create(proc_current, entry, args);

    deque_push_back(&proc_runq, as(*DequeNode, child));

    return child.pid;
}

fn sys_waitpid(r: *regs_t) u32 {
    var want: i32 = r.ebx;
    var p_status: *u32 = as(*u32, r.ecx);

    var z: *Process = proc_current.child_head;
    while (z != null) {
        if (want == -1 || want == z.pid) {
            break;
        }
        z = z.sibling_next;
    }

    if (z == null) {
        return -1;
    }

    if (z.state == P_ZOMBIE) {
        var pid: i32 = z.pid;
        if (p_status != null) {
            *p_status = z.exit_status;
        }
        proc_reap(z);
        return pid;
    }

    proc_current.state = P_BLOCKED;
    proc_current.wait_type = WAIT_WAITPID;
    proc_current.wait_want_pid = want;
    proc_current.wait_regs = r;
    proc_current.wait_p_status = p_status;

    proc_schedule(r);
    // unreachable
}

fn syscall_isr(r: *regs_t) void {
    if (r.eax < SYS_COUNT) {
        r.eax = syscall_handlers[r.eax](r);
        return;
    }

    panic("Unknown syscall: %d", r.eax);
}

fn syscall_init() void {
    isr_install_handler(0x7F, syscall_isr);

    syscall_handlers[SYS_EXIT] = sys_exit;
    syscall_handlers[SYS_GETPID] = sys_getpid;
    syscall_handlers[SYS_SPAWN] = sys_spawn;
    syscall_handlers[SYS_WAITPID] = sys_waitpid;
}

#endif

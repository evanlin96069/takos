#if !SYS
#define SYS

#include "idt.ika"
#include "paging.ika"
#include "interrupt.ika"

#include "malloc.ika"
#include "panic.ika"
#include "process.ika"
#include "syscall.ika"

var syscall_handlers: [SYS_COUNT]fn(r: *regs_t) u32;

fn sys_exit(r: *regs_t) u32 {
    var status: u32 = r.ebx;

    var p: *Process = proc_current;
    p.exit_status = status & 0xFF;
    p.state = P_ZOMBIE;

    if (p == init_proc) {
        panic("init (PID 1) exited with status %d", p.exit_status);
    }

    proc_reparent_children(p, init_proc);

    proc_wake_waitpid_if_match(p.parent, p);

    proc_schedule(r);
    // unreachable
}

fn sys_getpid(r: *regs_t) u32 {
    return proc_current.pid;
}

fn sys_fork(r: *regs_t) u32 {
    return -1;
}

fn sys_waitpid(r: *regs_t) u32 {
    var want: i32 = r.ebx;
    var p_status: *u32 = as(*u32, r.ecx);

    var z: *Process = proc_current.child_head;
    while (z != null) {
        if (z.state == P_ZOMBIE && (want == -1 || want == z.pid)) {
            break;
        }
        z = z.sibling_next;
    }

    if (z != null) {
        var pid: i32 = z.pid;
        if (p_status != null) {
            *p_status = z.exit_status;
        }
        proc_reap(z);
        r.eax = pid;
        return 0;
    }

    proc_current.state = P_BLOCKED;
    proc_current.wait_type = WAIT_WAITPID;
    proc_current.wait_want_pid = want;
    proc_current.wait_regs = r;
    proc_current.wait_p_status = p_status;

    proc_schedule(r);
    // unreachable
}

fn syscall_isr(r: *regs_t) void {
    if (r.eax < SYS_COUNT) {
        interrupt_disable();
        r.eax = syscall_handlers[r.eax](r);
        return;
    }

    panic("Unknown syscall: %d", r.eax);
}

fn syscall_init() void {
    isr_install_handler(0x7F, syscall_isr);

    syscall_handlers[SYS_EXIT] = sys_exit;
    syscall_handlers[SYS_GETPID] = sys_getpid;
    syscall_handlers[SYS_FORK] = sys_fork;
    syscall_handlers[SYS_WAITPID] = sys_waitpid;
}

#endif

#include "boot_info.ika"

// arch
#include "gdt.ika"
#include "idt.ika"
#include "isr.ika"
#include "irq.ika"
#include "interrupt.ika"
#include "pmm.ika"
#include "vmm.ika"

// drivers
#include "console.ika"
#include "timer.ika"
#include "kbd.ika"

// lib
#include "print.ika"
#include "getc.ika"
#include "time.ika"
#include "malloc.ika"

// fs
#include "vfs.ika"
#include "ext2.ika"
#include "initrd.ika"

fn color_test() void {
    "Color test:\n";
    "Standard: ";
    "\x1b[97;40m   0 \x1b[0m";
    "\x1b[97;41m   1 \x1b[0m";
    "\x1b[97;42m   2 \x1b[0m";
    "\x1b[97;43m   3 \x1b[0m";
    "\x1b[97;44m   4 \x1b[0m";
    "\x1b[97;45m   5 \x1b[0m";
    "\x1b[97;46m   6 \x1b[0m";
    "\x1b[97;47m   7 \x1b[0m";

    "\nIntense:  ";
    "\x1b[30;100m   8 \x1b[0m";
    "\x1b[30;101m   9 \x1b[0m";
    "\x1b[30;102m  10 \x1b[0m";
    "\x1b[30;103m  11 \x1b[0m";
    "\x1b[30;104m  12 \x1b[0m";
    "\x1b[30;105m  13 \x1b[0m";
    "\x1b[30;106m  14 \x1b[0m";
    "\x1b[30;107m  15 \x1b[0m";
    "\x1b[0m\n";
}

fn dump_boot_info(info: *BootInfo) void {
    "Kernel end: 0x%x\n", info.kernel_end;
    "Memory map:\n";
    var i: u32 = 0;
    while (i < info.mmap_count) : (i += 1) {
        if (info.mmap[i].base.high == 0 && info.mmap[i].length.high == 0) {
            "mmap[%d]:\n", i;
            "    addr: 0x%x\n", info.mmap[i].base.low;
            "    length: %u\n", info.mmap[i].length.low;
        }
    }

    "Modules:\n";
    i = 0;
    while (i < info.module_count) : (i += 1) {
        "module[%d]:\n", i;
        "    start: 0x%x\n", info.modules[i].start;
        "    end: 0x%x\n", info.modules[i].end;
    }
}

fn kbd_test() void {
    "Keyboard test: ";
    while (true) {
        var c: i32 = getchar();
        putchar(c);
        if (c == '\n') {
            break;
        }
    }
}

fn timer_test() void {
    "Timer test:\n";
    var i: u32 = 0;
    while (i < 5) {
        i += 1;
        sleep(1000);
        if (i == 1) {
            "%d second has passed\n", i;
        } else {
            "%d seconds have passed\n", i;
        }
    }
}

pub fn cat(path: []u8) void {
    var f: *File;
    var state: i32 = vfs_open(path, &f);
    if (state != 0) {
        "cat: cannot open %s\n", path;
        return;
    }

    var n: i32;
    const BUF_SIZE = 256;
    var buf: [BUF_SIZE]u8;
    while ((n = vfs_read(f, &buf, BUF_SIZE-1)) > 0) {
        buf[BUF_SIZE-1] = 0;
        puts(&buf);
    }

    if (n < 0) {
        "\ncat: read error\n";
    }

    vfs_close(f);
}

pub fn kmain(info: *BootInfo) void {
    // core modules
    gdt_init();
    idt_init();
    isr_init();
    irq_init();

    console_init();

    dump_boot_info(info);

    // hardware drivers
    timer_init(10000);
    kbd_init();

    // memory management
    pmm_init(info);
    vmm_init(info);

    // file system
    vfs_init();
    ext2_init();
    initdr_mount(info);

    interrupt_enable();

    "takos is running! %s\n", "WAH!";

    color_test();
    "File system test:\n";
    "cat /etc/hostname\n";
    cat("/etc/hostname");
    kbd_test();
    timer_test();

    "Interrupt test:\n";
    breakpoint();
}

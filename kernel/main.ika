#include "boot_info.ika"

// arch
#include "gdt.ika"
#include "tss.ika"
#include "idt.ika"
#include "isr.ika"
#include "irq.ika"
#include "interrupt.ika"
#include "pmm.ika"
#include "vmm.ika"

// drivers
#include "console.ika"
#include "timer.ika"
#include "kbd.ika"

// lib
#include "print.ika"
#include "getc.ika"
#include "time.ika"
#include "malloc.ika"

// fs
#include "vfs.ika"
#include "ext2.ika"
#include "initrd.ika"

// syscall
#include "sys.ika"

fn color_test() void {
    "Color test:\n";
    "Standard: ";
    "\x1b[97;40m   0 \x1b[0m";
    "\x1b[97;41m   1 \x1b[0m";
    "\x1b[97;42m   2 \x1b[0m";
    "\x1b[97;43m   3 \x1b[0m";
    "\x1b[97;44m   4 \x1b[0m";
    "\x1b[97;45m   5 \x1b[0m";
    "\x1b[97;46m   6 \x1b[0m";
    "\x1b[97;47m   7 \x1b[0m";

    "\nIntense:  ";
    "\x1b[30;100m   8 \x1b[0m";
    "\x1b[30;101m   9 \x1b[0m";
    "\x1b[30;102m  10 \x1b[0m";
    "\x1b[30;103m  11 \x1b[0m";
    "\x1b[30;104m  12 \x1b[0m";
    "\x1b[30;105m  13 \x1b[0m";
    "\x1b[30;106m  14 \x1b[0m";
    "\x1b[30;107m  15 \x1b[0m";
    "\x1b[0m\n";
}

fn dump_boot_info(info: *BootInfo) void {
    "Kernel end: 0x%x\n", info.kernel_end;
    "Memory map:\n";
    var i: u32 = 0;
    while (i < info.mmap_count) : (i += 1) {
        if (info.mmap[i].base.high == 0 && info.mmap[i].length.high == 0) {
            "mmap[%d]:\n", i;
            "    addr: 0x%x\n", info.mmap[i].base.low;
            "    length: %u\n", info.mmap[i].length.low;
        }
    }

    "Modules:\n";
    i = 0;
    while (i < info.module_count) : (i += 1) {
        "module[%d]:\n", i;
        "    start: 0x%x\n", info.modules[i].start;
        "    end: 0x%x\n", info.modules[i].end;
    }
}

fn kbd_test() void {
    "Keyboard test: ";
    while (true) {
        var c: i32 = getchar();
        putchar(c);
        flush();
        if (c == '\n') {
            break;
        }
    }
}

fn timer_test() void {
    "Timer test:\n";
    var i: u32 = 0;
    while (i < 5) {
        i += 1;
        sleep(1000);
        if (i == 1) {
            "%d second has passed\n", i;
        } else {
            "%d seconds have passed\n", i;
        }
    }
}

fn builtin_cat(path: []u8) void {
    var f: *File;
    var state: i32 = vfs_open(path, &f);
    if (state != 0) {
        "cat: cannot open %s\n", path;
        return;
    }

    var n: i32;
    const BUF_SIZE = 256;
    var buf: [BUF_SIZE]u8;
    while ((n = vfs_read(f, &buf, BUF_SIZE-1)) > 0) {
        buf[n] = 0;
        puts(&buf);
    }

    flush();

    if (n < 0) {
        "\ncat: read error\n";
    }

    vfs_close(f);
}

fn builtin_ls(path: []u8) void {
    var dir: *File;
    if (vfs_opendir(path, &dir) != 0) {
        "ls: cannot open %s\n", path;
        return;
    }

    var ent: Dirent;
    while (vfs_readdir(dir, &ent) > 0) {
        var end: []u8 = "";
        if (ent.type == DT_DIR) {
            end = "/";
        }
        "%s%s ", &ent.name, end;
    }
    "\n";
    vfs_close(dir);
}

fn fs_test() void {
    "File system test:\n";
    "$ ls /\n";
    builtin_ls("/");
    "$ cat /etc/hostname\n";
    builtin_cat("/etc/hostname");
}

fn prog_main(args: *void) u32 {
    "[child] pid=%d\n", getpid();

    return 69;
}

fn init_main(args: *void) u32 {
    var pid: i32 = spawn(prog_main, null);
    "[parent] pid=%d, child=%d\n", getpid(), pid;

    var status: u32;
    waitpid(pid, &status);
    "[parent] child exit with %d\n", status;

    while (true) {}
}

pub fn kmain(info: *BootInfo) void {
    // core modules
    gdt_init();
    tss_init();
    idt_init();
    isr_init();
    irq_init();

    console_init();
 
    // dump_boot_info(info);

    // hardware drivers
    timer_init(1000);
    kbd_init();

    // memory management
    pmm_init(info);
    vmm_init(info);

    // file system
    vfs_init();
    ext2_init();
    initrd_mount(info);

    color_test();
    fs_test();

    "takos is running! %s\n", "WAH!";

    // user mode
    syscall_init();
    proc_init(init_main);
    proc_start();
}

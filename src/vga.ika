#if !VGA
#define VGA

#include "lib/mem.ika"
#include "lib/va_arg.ika"

const VGA_W = 80;
const VGA_H = 25;

enum {
    VGA_COLOR_BLACK = 0,
    VGA_COLOR_BLUE = 1,
    VGA_COLOR_GREEN = 2,
    VGA_COLOR_CYAN = 3,
    VGA_COLOR_RED = 4,
    VGA_COLOR_MAGENTA = 5,
    VGA_COLOR_BROWN = 6,
    VGA_COLOR_LIGHT_GREY = 7,
    VGA_COLOR_DARK_GREY = 8,
    VGA_COLOR_LIGHT_BLUE = 9,
    VGA_COLOR_LIGHT_GREEN = 10,
    VGA_COLOR_LIGHT_CYAN = 11,
    VGA_COLOR_LIGHT_RED = 12,
    VGA_COLOR_LIGHT_MAGENTA = 13,
    VGA_COLOR_LIGHT_BROWN = 14,
    VGA_COLOR_WHITE = 15,
};

var vga_text: []u16;
var vga_attribute: u8 = VGA_COLOR_LIGHT_GREY;
var vga_cursor_x: u8 = 0;
var vga_cursor_y: u8 = 0;

fn scroll() void {
    var blank: u16 = ' ' | vga_attribute << 8;
    if (vga_cursor_y >= VGA_H) {
        var temp: u16 = vga_cursor_y - VGA_H + 1;
        memcpy(vga_text, vga_text + temp * VGA_W, (VGA_H - temp) * VGA_W * 2);
        wmemset(vga_text + (VGA_H - temp) * VGA_W, blank, VGA_W);
        vga_cursor_y = 25 - 1;
    }
}

fn cls() void {
    var blank: u16 = ' ' | vga_attribute << 8;
    wmemset(vga_text, blank, VGA_W * VGA_H);

    vga_cursor_x = 0;
    vga_cursor_y = 0;
}

fn putchar(c: u8) i32 {
    if (c == 0x08) {
        // backspace
        if (vga_cursor_x != 0) {
            vga_cursor_x -= 1;
        }
    } else if (c == '\t') {
        vga_cursor_x = (vga_cursor_x + 8) & ~(8 - 1);
    } else if (c == '\r') {
        vga_cursor_x = 0;
    } else if (c == '\n') {
        vga_cursor_x = 0;
        vga_cursor_y += 1;
    } else if (c >= ' ') {
        vga_text[vga_cursor_y * VGA_W + vga_cursor_x] = c | vga_attribute << 8;
        vga_cursor_x += 1;
    }

    if (vga_cursor_x >= 80) {
        vga_cursor_x = 0;
        vga_cursor_y += 1;
    }

    scroll();

    return c;
}

fn puts(s: []u8) i32 {
    if (s == null) {
        return 0;
    }

    var i: u32 = 0;
    while (s[i] != 0) : (i += 1) {
        putchar(s[i]);
    }

    return i;
}

fn toupper(ch: u8) u8 {
    if (ch >= 'a' && ch <= 'z') {
        ch = ch - 'a' + 'A';
    }
    return ch;
}

fn tolower(ch: u8) u8 {
    if (ch >= 'A' && ch <= 'Z') {
        ch = ch - 'A' + 'a';
    }
    return ch;
}

fn itoa(value: i32, str: []u8, base: i32) []u8 {
    const digits = "0123456789abcdef";

    var i: u32 = 0;
    var negative: bool = false;

    if (value == 0) {
        str[0] = '0';
        str[1] = 0;
        return str;
    }

    if (value < 0 && base == 10) {
        negative = true;
        value = -value;
    }

    while (value != 0) : (value /= base) {
        var rem: u32 = value % base;
        str[i] = digits[rem];
        i += 1;
    }

    if (negative) {
        str[i] = '-';
        i += 1;
    }

    str[i] = 0;

    // reverse string
    var start: u32 = 0;
    var end: u32 = i - 1;
    while (start < end) {
        var temp: u8 = str[start];
        str[start] = str[end];
        str[end] = temp;
        end -= 1;
        start += 1;
    }
    return str;
}

fn printf(fmt: []u8, ...) i32 {
    var ap: va_list;
    va_start(&ap, &fmt, sizeof([]u8));

    var count: i32 = 0;

    while (*fmt != 0) : (fmt += 1) {
        if (*fmt != '%') {
            putchar(*fmt);
            count += 1;
            continue;
        }

        fmt += 1;

        if (*fmt == 'c') {
            putchar(*as(*u8, va_arg(&ap, sizeof(u8))));
        } else if (*fmt == 's') {
            var s: []u8 = *as(*[]u8, va_arg(&ap, sizeof([]u8)));
            if (s == null) {
                s = "(null)";
            }
            count += puts(s);
        } else if (*fmt == '%') {
            putchar('%');
            count += 1;
        } else if (*fmt == 'd') {
            var n: i32 = *as(*i32, va_arg(&ap, sizeof(i32)));
            var buf: [16]u8;
            count += puts(itoa(n, &buf, 10));
        } else if (*fmt == 'p' || *fmt == 'x' || *fmt == 'X') {
            if (*fmt == 'p') {
                count += puts("0x");
            }
            var n: u32 = *as(*u32, va_arg(&ap, sizeof(u32)));
            var buf: [16]u8;

            var s: []u8 = itoa(n, &buf, 16);
            var i: u32 = 0;
            while (s[i] != 0) : (i += 1) {
                s[i] = toupper(s[i]);
            }
            count += puts(s);
        } else {
            putchar('%');
            putchar(*fmt);
            count += 2;
        }
    }

    va_end(&ap);
    return count;
}

fn vga_setcolor(fg: u16, bg: u16) void {
    vga_attribute = (bg << 4) | (fg & 0x0F);
}

fn vga_init() void {
    vga_text = as([]u16, 0xB8000);
    cls();
}

#endif
